/*******************************************************************************
 * @file     nb_control_thread.c
 * @author   lcc
 * @version
 * @date     2022-08-03
 * @brief
 ******************************************************************************/

/*
 *                    (Y+)
 *                M1    ↑    M2
 *                  \   |   /
 *                   \  |  /
 *                    \ | /
 *              ————————+————————>X+
 *                    / | \
 *                   /  |  \
 *                  /   |   \
 *                M4    |    M3
 */
#include "nb_common.h"
#include "inv_mpu.h"
#include "inv_mpu_dmp_motion_driver.h"
#include "rtt_mpu_adpt.h"
#include "rtt_mpu_config.h"
#include "invensense.h"
#include "eMPL_outputs.h"

#include <rtthread.h>
#include <board.h>

#define DBG_TAG     "app.control"
#define DBG_LVL     3
#include <rtdbg.h>

///* Data read from MPL. */
//#define PRINT_ACCEL     (0x01)
//#define PRINT_GYRO      (0x02)
//#define PRINT_QUAT      (0x04)
//#define PRINT_COMPASS   (0x08)
//#define PRINT_EULER     (0x10)
//#define PRINT_ROT_MAT   (0x20)
//#define PRINT_HEADING   (0x40)
//#define PRINT_PEDO      (0x80)
//#define PRINT_LINEAR_ACCEL (0x100)
//#define PRINT_GRAVITY_VECTOR (0x200)

typedef enum {
    PACKET_DATA_ACCEL = 0,
    PACKET_DATA_GYRO,
    PACKET_DATA_COMPASS,
    PACKET_DATA_QUAT,
    PACKET_DATA_EULER,
    PACKET_DATA_ROT,
    PACKET_DATA_HEADING,
    PACKET_DATA_LINEAR_ACCEL,
    NUM_DATA_PACKETS
} eMPL_packet_e;

#define PACKET_LENGTH 23

#define PACKET_DEBUG    (1)
#define PACKET_QUAT     (2)
#define PACKET_DATA     (3)

#if 0
/* Get data from MPL.
 * TODO: Add return values to the inv_get_sensor_type_xxx APIs to differentiate
 * between new and stale data.
 */
static void read_from_mpl(void)
{
    long msg, data[9];
    int8_t accuracy;
    unsigned long timestamp;
    float float_data[3] = {0};

    if (inv_get_sensor_type_quat(data, &accuracy, (inv_time_t*)&timestamp)) {
       /* Sends a quaternion packet to the PC. Since this is used by the Python
        * test app to visually represent a 3D quaternion, it's sent each time
        * the MPL has new data.
        */
        eMPL_print_quat(data);

        /* Specific data packets can be sent or suppressed using USB commands. */
        if (hal.report & PRINT_QUAT)
            eMPL_print_data(PACKET_DATA_QUAT, data);
    }

    if (hal.report & PRINT_ACCEL) {
        if (inv_get_sensor_type_accel(data, &accuracy,
            (inv_time_t*)&timestamp))
            eMPL_print_data(PACKET_DATA_ACCEL, data);
    }
    if (hal.report & PRINT_GYRO) {
        if (inv_get_sensor_type_gyro(data, &accuracy,
            (inv_time_t*)&timestamp))
            eMPL_print_data(PACKET_DATA_GYRO, data);
    }
#ifdef COMPASS_ENABLED
    if (hal.report & PRINT_COMPASS) {
        if (inv_get_sensor_type_compass(data, &accuracy,
            (inv_time_t*)&timestamp))
            eMPL_print_data(PACKET_DATA_COMPASS, data);
    }
#endif
    if (hal.report & PRINT_EULER) {
        if (inv_get_sensor_type_euler(data, &accuracy,
            (inv_time_t*)&timestamp))
            eMPL_print_data(PACKET_DATA_EULER, data);
    }
    if (hal.report & PRINT_ROT_MAT) {
        if (inv_get_sensor_type_rot_mat(data, &accuracy,
            (inv_time_t*)&timestamp))
            eMPL_print_data(PACKET_DATA_ROT, data);
    }
    if (hal.report & PRINT_HEADING) {
        if (inv_get_sensor_type_heading(data, &accuracy,
            (inv_time_t*)&timestamp))
            eMPL_print_data(PACKET_DATA_HEADING, data);
    }
    if (hal.report & PRINT_LINEAR_ACCEL) {
        if (inv_get_sensor_type_linear_acceleration(float_data, &accuracy, (inv_time_t*)&timestamp)) {
            LOG_I("Linear Accel: %7.5f %7.5f %7.5f\r\n",
                    float_data[0], float_data[1], float_data[2]);
         }
    }
    if (hal.report & PRINT_GRAVITY_VECTOR) {
            if (inv_get_sensor_type_gravity(float_data, &accuracy,
                (inv_time_t*)&timestamp))
                LOG_I("Gravity Vector: %7.5f %7.5f %7.5f\r\n",
                        float_data[0], float_data[1], float_data[2]);
    }
    if (hal.report & PRINT_PEDO) {
        unsigned long timestamp;
        rt_get_uptime_ms(&timestamp);
        if (timestamp > hal.next_pedo_ms) {
            hal.next_pedo_ms = timestamp + PEDO_READ_MS;
            unsigned long step_count, walk_time;
            dmp_get_pedometer_step_count(&step_count);
            dmp_get_pedometer_walk_time(&walk_time);
            LOG_I("Walked %ld steps over %ld milliseconds..\n", step_count,
            walk_time);
        }
    }

    /* Whenever the MPL detects a change in motion state, the application can
     * be notified. For this example, we use an LED to represent the current
     * motion state.
     */
    msg = inv_get_message_level_0(INV_MSG_MOTION_EVENT |
            INV_MSG_NO_MOTION_EVENT);
    if (msg) {
        if (msg & INV_MSG_MOTION_EVENT) {
            LOG_I("Motion!\n");
        } else if (msg & INV_MSG_NO_MOTION_EVENT) {
            LOG_I("No motion!\n");
        }
    }
}
#endif

//q30，q16格式,long转float时的除数.
#define q30  1073741824.0f
#define q16  65536.0f

void nb_control_thread_entry(void *parameter)
{
    rt_err_t result;
    unsigned char new_temp = 0;

    unsigned long timestamp;

    long data[3];
    int8_t accuracy;

    result = rt_mpu6050_init("i2c1", NB_MPU6050_IND_PIN);
    if (result < 0) {
        LOG_E("rt_mpu6050_init failed");
        return;
    }
    LOG_D("rt_mpu6050_init OK");
    while (1) {
        unsigned long sensor_timestamp;
        int new_data = 0;

        rt_get_uptime_ms(&timestamp);

        /* Temperature data doesn't need to be read with every gyro sample.
         * Let's make them timer-based like the compass reads.
         */
        if (timestamp > hal.next_temp_ms) {
            hal.next_temp_ms = timestamp + TEMP_READ_MS;
            new_temp = 1;
        }

        if (hal.irq_sem != RT_NULL) {
            rt_sem_take(hal.irq_sem, RT_WAITING_FOREVER);
        } else {
            rt_thread_mdelay(100);
        }

        if (hal.new_gyro && hal.lp_accel_mode) {
            short accel_short[3];
            long accel[3];
            mpu_get_accel_reg(accel_short, &sensor_timestamp);
            accel[0] = (long)accel_short[0];
            accel[1] = (long)accel_short[1];
            accel[2] = (long)accel_short[2];
            inv_build_accel(accel, 0, sensor_timestamp);
            new_data = 1;
            hal.new_gyro = 0;
        } else if (hal.new_gyro && hal.dmp_on) {
            short gyro[3], accel_short[3], sensors;
            unsigned char more;
            long accel[3], quat[4], temperature;
            /* This function gets new data from the FIFO when the DMP is in
             * use. The FIFO can contain any combination of gyro, accel,
             * quaternion, and gesture data. The sensors parameter tells the
             * caller which data fields were actually populated with new data.
             * For example, if sensors == (INV_XYZ_GYRO | INV_WXYZ_QUAT), then
             * the FIFO isn't being filled with accel data.
             * The driver parses the gesture data to determine if a gesture
             * event has occurred; on an event, the application will be notified
             * via a callback (assuming that a callback function was properly
             * registered). The more parameter is non-zero if there are
             * leftover packets in the FIFO.
             */
            dmp_read_fifo(gyro, accel_short, quat, &sensor_timestamp, &sensors, &more);
            LOG_D("timestamp %d, sensors %04x, more %d", sensor_timestamp, sensors, more);
            LOG_D("gyro [%d %d %d], accel_short [%d %d %d], quat [%d %d %d %d]",
                  gyro[0], gyro[1], gyro[2], accel_short[0], accel_short[1], accel_short[2],
                  quat[0], quat[1], quat[2], quat[3]);
            if (!more)
                hal.new_gyro = 0;
            if (sensors & INV_XYZ_GYRO) {
                /* Push the new data to the MPL. */
                inv_build_gyro(gyro, sensor_timestamp);
                new_data = 1;
                if (new_temp) {
                    new_temp = 0;
                    /* Temperature only used for gyro temp comp. */
                    mpu_get_temperature(&temperature, &sensor_timestamp);
                    inv_build_temp(temperature, sensor_timestamp);
                }
            }
            if (sensors & INV_XYZ_ACCEL) {
                accel[0] = (long)accel_short[0];
                accel[1] = (long)accel_short[1];
                accel[2] = (long)accel_short[2];
                inv_build_accel(accel, 0, sensor_timestamp);
                new_data = 1;
            }
            if (sensors & INV_WXYZ_QUAT) {
                inv_build_quat(quat, 0, sensor_timestamp);
                new_data = 1;
            }
        } else if (hal.new_gyro) {
            short gyro[3], accel_short[3];
            unsigned char sensors, more;
            long accel[3], temperature;
            /* This function gets new data from the FIFO. The FIFO can contain
             * gyro, accel, both, or neither. The sensors parameter tells the
             * caller which data fields were actually populated with new data.
             * For example, if sensors == INV_XYZ_GYRO, then the FIFO isn't
             * being filled with accel data. The more parameter is non-zero if
             * there are leftover packets in the FIFO. The HAL can use this
             * information to increase the frequency at which this function is
             * called.
             */
            hal.new_gyro = 0;
            mpu_read_fifo(gyro, accel_short, &sensor_timestamp,
                &sensors, &more);
            LOG_D("gyro [%d %d %d], accel_short [%d %d %d]",
                  gyro[0], gyro[1], gyro[2], accel_short[0], accel_short[1], accel_short[2]);
            if (more)
                hal.new_gyro = 1;
            if (sensors & INV_XYZ_GYRO) {
                /* Push the new data to the MPL. */
                inv_build_gyro(gyro, sensor_timestamp);
                new_data = 1;
                if (new_temp) {
                    new_temp = 0;
                    /* Temperature only used for gyro temp comp. */
                    mpu_get_temperature(&temperature, &sensor_timestamp);
                    inv_build_temp(temperature, sensor_timestamp);
                }
            }
            if (sensors & INV_XYZ_ACCEL) {
                accel[0] = (long)accel_short[0];
                accel[1] = (long)accel_short[1];
                accel[2] = (long)accel_short[2];
                inv_build_accel(accel, 0, sensor_timestamp);
                new_data = 1;
            }
        }

        if (new_data) {
            inv_execute_on_data();
            /* This function reads bias-compensated sensor data and sensor
             * fusion outputs from the MPL. The outputs are formatted as seen
             * in eMPL_outputs.c. This function only needs to be called at the
             * rate requested by the host.
             */
            inv_get_sensor_type_euler(data, &accuracy, &timestamp);
            //LOG_I("%d: roll %lf, pitch %lf, yaw %lf", timestamp, data[0]/q16, -data[1]/q16, -data[2]/q16);
            LOG_I("%d: roll %ld, pitch %ld, yaw %ld", timestamp, data[0], data[1], data[2]);
        }
    }
}

static int control_app_init(void)
{
    rt_thread_t tid;

    tid = rt_thread_create("control_thread", nb_control_thread_entry, RT_NULL,
                           6144,    /* stack size */
                           10,      /* priority */
                           5);      /* time slice */
    if (tid != RT_NULL)
    {
        rt_thread_startup(tid);
        return 0;
    }
    else
    {
        return -1;
    }
}

INIT_APP_EXPORT(control_app_init);
